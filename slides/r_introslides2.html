<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <title>An Introduction to R: Data Cleaning, Wrangling, Visualizing, and Everything Else</title>
    <meta charset="utf-8" />
    <meta name="author" content="Daniel Katz" />
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, my-title, title-slide

# An Introduction to R: Data Cleaning, Wrangling, Visualizing, and Everything Else
## Part 3
### Daniel Katz

---


class: middle




# Enough Putzing about, Let's get to Data

+ The type of data structure you will mostly work with in R is the dataframe. Or, &lt;mark&gt;data.frame&lt;/mark&gt; 

+ Other common types of data structures:
  + `matrix`
  + `lists`
  + `arrays`

---
## Arrays

+ An array is a general multidimensional data structure 
  + mindblowingly, a matrix that essentially has an x, y, and a z axis (or more!)
--
+ One can make lists of matrices or dataframes, and lists can be [_**IN dataframes**_](https://jennybc.github.io/purrr-tutorial/ls13_list-columns.html)  

  + For instance, sometimes, you want to do the same thing to a number of dataframes [_**iteration**_](https://r4ds.had.co.nz/iteration.html).
  + If you put them in a list, you have a method for doing this very easily (we'll see later)
  
---

class: middle

## Getting data sets in to R with the `readr` package
+ The first challenge: getting data into R

+ R needs a command to read in the data

+ R needs a &lt;mark&gt;path&lt;/mark&gt;, where to find the data

+ We're going to use the [_**`readr`**_](https://readr.tidyverse.org/) package to handle most file types

+ However, the `foreign` package and `haven` package can handle files from SAS, SPSS, STATA (and probably others)

+ You don't need SPSS, SAS, or STATA to read data into R

---

class: middle

## First, things first
+ Download the data!

+ The data today is a publically accessible dataset from the [_**California Department of Education**_](https://www.cde.ca.gov/ds/sd/sd/filescohort.asp)

+ Download by clicking: [**Example Data 1**](/CDRPdata/cohort16.csv)

+ I've posted it on the workshop web here: [_**CDEDATA**_](http://www.dbkatz.com/1/01/01/beginning-a-new-intro-to-r-workshop/)

+ And put it in your working directory

+ My what?


```r
# this will tell you the file path of your current working directory. The best thing is to put it here, since your Rproject is here. 
getwd()
```

```
## [1] "C:/Users/katzd/Desktop/Github/perswebsite2/static/slides"
```

---
## A Rare Best Practice

1. It is recommend that you create, in your working directory, folders just for the initial raw data (this data isn't to be altered) 

1. Another folder in your working directory just for altered datasets (with computed variables, cleaned, or otherwise changed data)

1. Another folder just for statistical output and plots (or divide)

&lt;img src="directory.jpg" width="360" /&gt;

*(if you put it in your working directory, you'll see it straight away, if not, you'll have to find it)


---

## Read in the data, the cheating way...
1. First create a new script in R, save it, and call it `learning_tidyverse`.

1.  In the top right, under the Global Environment tab, it says "Import Dataset"

1. The file we downloaded is a CSV file (make sure to use readr)

1. Select `Import Dataset` &gt; `From Text (readr)` &gt; `Browse` &gt; Find the dataset*, select, and open &gt; look at the preview

1. If it doesn't look right, you can play with the settings (probably have to change, delimiter)


# Don't import yet!

---

## The final steps
1. In the lower right, there is some code, &lt;mark&gt;copy it&lt;/mark&gt; and cancel out

1. Paste the code into your new script at the top; write a note about what it is

1. Eventually, you'll want to do this manually, I promise (and please promise me)

&lt;img src="importing.jpg" width="536" /&gt;

---
## Code for Reading in 
+ Run all the code...



```r
# Now that I've put my files in a rawdata folder 
#in the working directory, I can do this:

# Load the library
library(readr)

co16 &lt;- read_csv("RawData/cohort16.csv")
View(co16)



#Alternatively you can save the object location (makes life easier)

# Assign a variable with a string value of the file location.
cohortdata &lt;- "RawData/cohort16.csv"

# Put the variable in your function, `read_delim`
co16 &lt;- read_csv(cohortdata)

# Note the View(function) - Let's you see the data
#View(cohort16)
```

---
class: middle

### Can also go searching for it with a longer path (doesn't need to be in your working directory)

```r
co16 &lt;- read_csv("C:/Users/katzd/Desktop/Github/perswebsite2/static/CDRPdata/cohort16.csv")
```
---
## Missing data in R...
+ Missing data in `R` appears as `NA`

+ The philosophy in R regarding `NA` is that it's an unknown value, kind of like a latent variable (many, in fact, consider latent variable modelling just soliving a missing data problem)

+ Therefore, base R won't compute certain statistics if you don't use the command `na.rm=T` which tells it to compute the statistic by removing the missing cases (where T = TRUE)

+ Because: The mean isn't known with missing values, truly


```r
# Example"
missingvector &lt;- c(1,2, 3, 4, 5, NA)
mean(missingvector)
```

```
## [1] NA
```

```r
mean(missingvector, na.rm = T)
```

```
## [1] 3
```
---

# Introducing `dplyr`
[_**`dplyr`**_](https://dplyr.tidyverse.org/) is a package full of "verbs" that help us work on data. Some major verbs are

+ &lt;code&gt;filter()&lt;/code&gt; allows us to filter rows by certain values

+ &lt;code&gt;select()&lt;/code&gt; allows us to select or deselect columns by name

+ &lt;code&gt;mutate()&lt;/code&gt; allows us to create/compute new variables

---

## Data Sense

Let's get a sense of the data

```r
#get variable names

names(co16)
```

```
##  [1] "X1"                         "CDS"                       
##  [3] "Name"                       "AggLevel"                  
##  [5] "DFC"                        "Subgroup"                  
##  [7] "Subgrouptype"               "NumCohort"                 
##  [9] "NumGraduates"               "Cohort Graduation Rate"    
## [11] "NumDropouts"                "Cohort Dropout Rate"       
## [13] "NumSpecialEducation"        "Special Ed Completers Rate"
## [15] "NumStillEnrolled"           "Still Enrolled Rate"       
## [17] "NumGED"                     "GED Rate"                  
## [19] "Year"
```
---
Get the first 10 rows

```r
head(co16)
```

```
## # A tibble: 6 x 19
##      X1 CDS   Name  AggLevel DFC   Subgroup Subgrouptype NumCohort
##   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;            &lt;dbl&gt;
## 1     1 0161~ REAL~ D        Y     All      9                   NA
## 2     2 0161~ Impa~ D        Y     All      2                   NA
## 3     3 0161~ Impa~ D        Y     All      9                   NA
## 4     4 0161~ Impa~ D        Y     All      7                   NA
## 5     5 0161~ Silv~ D        Y     All      5                   11
## 6     6 0161~ Live~ D        Y     All      5                   27
## # ... with 11 more variables: NumGraduates &lt;dbl&gt;, `Cohort Graduation
## #   Rate` &lt;dbl&gt;, NumDropouts &lt;dbl&gt;, `Cohort Dropout Rate` &lt;dbl&gt;,
## #   NumSpecialEducation &lt;dbl&gt;, `Special Ed Completers Rate` &lt;dbl&gt;,
## #   NumStillEnrolled &lt;dbl&gt;, `Still Enrolled Rate` &lt;dbl&gt;, NumGED &lt;dbl&gt;,
## #   `GED Rate` &lt;dbl&gt;, Year &lt;dbl&gt;
```


---
## Using select to get RID of a column
We notice that the first column in the dataset is called `X1.` This column is added automatically when a dataframe is exported to csv from R. Let's get rid of it.  

We use a `-` sign before the column name. That's it. 


```r
co16_rem &lt;- select(co16, -X1)

#non tidyverse solution (remember indexing!!)
co16_rem &lt;- co16[-1]

#make sure this worked
names(co16_rem)
```

```
##  [1] "CDS"                        "Name"                      
##  [3] "AggLevel"                   "DFC"                       
##  [5] "Subgroup"                   "Subgrouptype"              
##  [7] "NumCohort"                  "NumGraduates"              
##  [9] "Cohort Graduation Rate"     "NumDropouts"               
## [11] "Cohort Dropout Rate"        "NumSpecialEducation"       
## [13] "Special Ed Completers Rate" "NumStillEnrolled"          
## [15] "Still Enrolled Rate"        "NumGED"                    
## [17] "GED Rate"                   "Year"
```

---

## Checking our work

+ Remember when we talked about `class`?

+ Well, let's make sure `CDS` which is a school ID, is of class `character`, how will we do this?

+ We don't want school ID to be a "numeric" variable of some sort - It's an ID so leading zeros matter

+ Using another R index tool, `$`, which selects column by name (auto complete should show you the name).

```r
class(co16_rem$CDS)
```

What about all variables?: Introducing `str()`


```r
str(co16_rem)
```
Easy!
---

class: middle 

## Explaining the data set (this is especially good for the tidyverse)

+ The variable `CDS` is a code for county, district, and schools.

+ This data contains information from state level, to county level, to district level, to school level.

+ It also contains information about demographics. Each demographic group per school, gets its own row and the numeric variables have to do with that particular subgroup in that school.

+ For instance, `AggLevel` denotes whether that row refers to "State", "County", "District," or "School"  
---

class: middle

+ If for instance, we take the first row, and first six columns
&lt;table&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:left;"&gt; CDS &lt;/th&gt;
   &lt;th style="text-align:left;"&gt; Name &lt;/th&gt;
   &lt;th style="text-align:left;"&gt; AggLevel &lt;/th&gt;
   &lt;th style="text-align:left;"&gt; DFC &lt;/th&gt;
   &lt;th style="text-align:left;"&gt; Subgroup &lt;/th&gt;
   &lt;th style="text-align:left;"&gt; Subgrouptype &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; 01611430122697 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; REALM Charter High &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; D &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; Y &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; All &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 9 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

+ We note, that the data for this row represents district totals, (so it's at the school level). 

+ It refers to the totals relevant to the state-identified `Subgroup`, "All".  
(codebook, here: [_**California Department of Education**_](https://www.cde.ca.gov/ds/sd/sd/filescohort.asp), that's an aggregation of those particular subgroups)
  
+ However, `Subgrouptype` is 9, which refers to: `9 – Two or more races, not Hispanic`

+ So that row refers to district total for that district for all students who have been identified as `Two or more races, not Hispanic` (you really get to see how the state of CA thinks)

+ Let's make this make sense, with `filter`
---
## Introducing `filter()` and pipe operators `%&gt;%`

+ Let's say, we want to know about average graduation rate
  + For the entire state
  + But just for non-charter schools
  + And for standard school districts

+ I know that in the `Name` column, there's school names and a value called "Statewide"

+ `filter` literally filters rows that meet a certain rule, such as equaling a value

+ `filter(df_name, rule)`

```r
stateco16 &lt;- filter(co16_rem, Name=="Statewide")
```
---
## Check for understanding, filter.

+ Let's say we only want to look at `district totals` data, not school level data. 

+ Use filter, on AggLevel such that we only select the category `D = Local educational agency totals (includes districts and direct funded charter schools)`

+ You'll have to start with `co16_rem` again  
--
## solution

```r
distr &lt;- filter(co16_rem, AggLevel == "D")

# Did it work?
table(distr$AggLevel)
```

```
## 
##     D 
## 19585
```

```r
#vs.

table(co16_rem$AggLevel)
```

```
## 
##     D     O     S     T 
## 19585  1814 53829    34
```
---

class: middle

## Piping Operators

+ However, we don't want to create a new object in R every time you perform an operation (we often perform a lot of operations and this gets confusing)

+ The `%&gt;%` operator, helps - read it as `and then`


```r
distr &lt;- co16_rem %&gt;% 
  filter(AggLevel == "D")

# table gives you counts on column (remember $ indexes)
table(distr$AggLevel)
```

```
## 
##     D 
## 19585
```

*What about filtering on more than one variable? That sounds like a challenge!*
---

.pull-left[We notice that even after filtering for District, individual charter schools are left in the dataset. 

1. The variable, &lt;mark&gt;DFC&lt;/mark&gt; contains information as to whether a school is a charter school or not. 
  + Y = Charter School
  + N = Not a charter school

2. The variable &lt;mark&gt;AggLevel&lt;/mark&gt; has information on level of analysis where
  + D = Local educational agency totals (includes districts and direct funded charter schools)
  + O = County totals
  + S = School totals
  + T = State totals]

.pull-right[1. Starting with the dataframe, `co16_rem`, create a new dataframe called `filtdf` by...

2. using `filter` so we only keep districts but remove charter schools.

3. Use filter and/or pipes so you only need to create one dataframe 

3. If you need the codebook, it is here: [_**California Department of Education**_](https://www.cde.ca.gov/ds/sd/sd/filescohort.asp)

*Hint* You can do this with one pipe or two. ]

---
# Solutions


```r
# Either one will work, I prefer method1
filtdf &lt;- co16_rem %&gt;% filter(DFC == "N", AggLevel == "D")

# or...

filtdf &lt;- co16_rem %&gt;% filter(DFC=="N") %&gt;% filter(AggLevel=="D")
```
---
# Challenge
1.After filtering, what categories are still left in the variable, `Agglevel`, in your new dataframe, filtdf?
  
2. Without creating a new R object, edit your script such that you keep only the category `All` from variable `Subgroup` and `All` from variable `Subgrouptype`. Make sure it is still called `filtdf`

---

## Solutions

```r
filtdf &lt;- co16_rem %&gt;% filter(DFC == "N", AggLevel == "D", 
                              Subgroup=="All", 
                              Subgrouptype=="All")

filtdf
```

```
## # A tibble: 493 x 18
##    CDS   Name  AggLevel DFC   Subgroup Subgrouptype NumCohort NumGraduates
##    &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;            &lt;dbl&gt;        &lt;dbl&gt;
##  1 0110~ Alam~ D        N     All      All                312          109
##  2 0161~ Alam~ D        N     All      All                727          632
##  3 0161~ Cast~ D        N     All      All                779          749
##  4 0161~ Pied~ D        N     All      All                206          205
##  5 0410~ Butt~ D        N     All      All                 76           37
##  6 0461~ Chic~ D        N     All      All               1093          979
##  7 0461~ Durh~ D        N     All      All                 67           65
##  8 0475~ Grid~ D        N     All      All                182          163
##  9 0861~ Del ~ D        N     All      All                216          197
## 10 1062~ Fres~ D        N     All      All               4488         3839
## # ... with 483 more rows, and 10 more variables: `Cohort Graduation
## #   Rate` &lt;dbl&gt;, NumDropouts &lt;dbl&gt;, `Cohort Dropout Rate` &lt;dbl&gt;,
## #   NumSpecialEducation &lt;dbl&gt;, `Special Ed Completers Rate` &lt;dbl&gt;,
## #   NumStillEnrolled &lt;dbl&gt;, `Still Enrolled Rate` &lt;dbl&gt;, NumGED &lt;dbl&gt;,
## #   `GED Rate` &lt;dbl&gt;, Year &lt;dbl&gt;
```
---
## Remember our logical operators Challenge

1. Now, using a pipe and assigning a new variable called `filtdf1000` (for exercise, not necessary, though), start with filtdf such that filtdf1000 only has districts with _at least_ 1000 students in its cohort (you'll need the variable NumCohort). 

---
## Solutions

```r
table(filtdf$AggLevel)
```

```
## 
##   D 
## 493
```

```r
filtdf1000 &lt;- filtdf %&gt;%
  filter(NumCohort &gt;= 1000)

range(filtdf$NumCohort)
```

```
## [1] NA NA
```

```r
nrow(filtdf) 
```

```
## [1] 493
```
---


class: middle


# Non-tidyverse solutions to filtering rows

### If I want to select particular rows, say, row 1, along with the fourth column:

+ `newdf &lt;- co16_rem[1, 4]` (where the first element represents row number, after the comma, the column (just like a matrix))

+ Just the first row: `newdf &lt;- co16_rem[1, ]`

### If I want to select rows according to rule (say, 1000): 
`newdf &lt;- co16_rem[co16_rem$numcohort &gt;= "1000", ]`

--
## For non-tidyverse solutions for selecting columns:
  + Indexing: co16_rem[1:4] (note, don't need commas) but same as co16_rem[, 1:4]
  + Naming `co16_rem$AggLevel`

---
class: middle

## tidyverse solution to selecting columns

+ Re-introducing `select()`

+ `select()` takes a dataframe name and the name of the columns you wish to select.

+ Typical use involves taking a very large dataset and selecting only the columns you need. 

+ You can also use `select()` to reorder columns, remove columns, and even rename columns

---
class: middle

# Example use:



```r
state16 &lt;- co16_rem %&gt;% 
  select(CDS, Name, NumCohort, NumGraduates)

# without a pipe operator
state16 &lt;- select(co16_rem , CDS, Name, NumCohort, NumGraduates)


names(state16)
```

```
## [1] "CDS"          "Name"         "NumCohort"    "NumGraduates"
```

```r
#or
View(state16)
```
---
class: middle

# Check for understanding `select()`:

1. Starting with co16_rem, edit the code from the previous slide so that you use a pipe operator, and select:

&lt;table&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:left;"&gt; Variable_Name &lt;/th&gt;
   &lt;th style="text-align:left;"&gt; Variable_Description &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; CDS &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; County, District, or School ID &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; Name &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; Name of State, County, District, or School &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; AggLevel &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; Level of Row Observation Statewide Totals(T), County Totals (0), District/Local Education Agency Totals (D), School Totals (S) &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; DFC &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; Direct Funded Charter: Yes (Y), No (N) &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; Subgroup &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; This is a coded field for identifying subgroups of students, such as, program participation and gender &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; Subgrouptype &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; This is a coded field for identifying racial/ethnic designation &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; NumCohort &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; Number of Students in the Cohort &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; NumGraduates &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; Number of students who graduated from the cohort &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;



---
# Solutions

```r
state16 &lt;- co16_rem %&gt;% select(CDS, Name, AggLevel, DFC, 
                      Subgroup, Subgrouptype, NumCohort, 
                      NumGraduates)
names(state16)
```

```
## [1] "CDS"          "Name"         "AggLevel"     "DFC"         
## [5] "Subgroup"     "Subgrouptype" "NumCohort"    "NumGraduates"
```
---
## Adding more to pipes
  
2. Using a pipe operator, add a filter command to your code, such that you select only district level data, D, (from AggLevel), only non-charter schools  ("N", from DFC), only `All` from both `Subgroup` and `Subgrouptype`

3. What is the largest value for `Numcohort`?


```r
state16 &lt;- co16_rem %&gt;% 
  select(CDS, Name, AggLevel, DFC, 
                      Subgroup, Subgrouptype, NumCohort, 
                      NumGraduates) %&gt;% 
  filter(AggLevel=="D", DFC=="N", Subgroup=="All", 
         Subgrouptype=="All")
```

```r
range(state16$NumCohort, na.rm=T)
```

```
## [1]    11 34472
```

```r
max(state16$NumCohort, na.rm=T)
```

```
## [1] 34472
```


Easy! 

---
class: middle

## Getting fancy

If you want to find the district with the largest cohort via dplyr:


```r
state16 %&gt;% 
  filter(NumCohort==max(NumCohort, na.rm=T)) %&gt;% 
  select(Name)
```

```
## # A tibble: 1 x 1
##   Name               
##   &lt;chr&gt;              
## 1 Los Angeles Unified
```

---
class: middle

## Something we haven't talked about yet... Variable types

+ The typical sort of stuff you see in SPSS for "types of variables" exists in R

+ Some of the major data structures you'll find that R recognizes:
  + `Character` - string variables/words/unordered
  + `Factors` - Categorical variable, usually ordered
  + `Numeric` (common types are integer and double, but it almost never matters [see here](https://www.burns-stat.com/documents/tutorials/impatient-r/more-r-key-objects/more-r-numbers/))
  + `Logical` (of the value, TRUE (T) or FALSE (F) or sometimes 1 or 0)
  + `Date and/or Time`


---

class: middle
### More on logicals

+ `TRUE` or `FALSE` have their own meaning in R - R knows what they mean

+ Always corresponds to 1 or 0 

+ As an example, run the code `T*1` and `F*1` 

+ If you remember the booleans, such as `&lt;=` they're evaluated as `TRUE` or `FALSE` 

---

class: middle 

## How R uses Logicals
+ When filtering, what we're really saying is...  _If this statement is TRUE, keep or discard these cases_

+ You can have an entire column in a dataframe that is a set of logicals (whether a student partook in a certain curriculum)

+ You might have a column of 1s or 0s - But you need R to recognize it as a Boolean or at least a factor level.

+ We'll have to coerce the column in a data frame, but first, `mutate()`
---

## Mutate

+ `Mutate()` is a function in dplyr used to create new columns or change existing ones. 

+ General form: `Mutate(df, new_variable_name = some_operation)`

+ Let's say I want a graduation rate. 


```r
state16 &lt;- state16 %&gt;% 
  mutate(gradrate = NumGraduates/NumCohort)

head(state16[5:length(state16)])
```

```
## # A tibble: 6 x 5
##   Subgroup Subgrouptype NumCohort NumGraduates gradrate
##   &lt;chr&gt;    &lt;chr&gt;            &lt;dbl&gt;        &lt;dbl&gt;    &lt;dbl&gt;
## 1 All      All                312          109    0.349
## 2 All      All                727          632    0.869
## 3 All      All                779          749    0.961
## 4 All      All                206          205    0.995
## 5 All      All                 76           37    0.487
## 6 All      All               1093          979    0.896
```

---

class: middle

## Challenge
1. Create a column using mutate that gives a standardized value of NumCohort for Districts in `State16`. Call the column StandCohort

2. Select all the cases in State16 that are at least two standard deviations above the mean NumCohort value based on your standardization

*Standardization/Z-Score = `\(\Sigma(x-\mu)/\sigma\)`*
1. You'll need to get the mean of Numcohort. 
1. You'll need to get the standard deviation of Numcohort. 
1. Use mutate

---
## Solution


```r
#### easier ###
mu &lt;- mean(state16$NumCohort, na.rm = T)
sigma &lt;- sd(state16$NumCohort, na.rm = T)

twosigma &lt;- state16 %&gt;% 
  mutate(StandCohort=(NumCohort-mu)/sigma) %&gt;% 
  filter(StandCohort &gt;= 2)

View(twosigma)
```


```r
# harder
twosigma &lt;- state16 %&gt;% mutate(StandCohort = (NumCohort - mean(NumCohort, na.rm = T))/sd(NumCohort, 
    na.rm = T)) %&gt;% filter(StandCohort &gt;= 2)
```


```r
# Best: using the function, scale()!!
state16 &lt;- state16 %&gt;% 
  mutate(StandCohort= scale(NumCohort)) %&gt;% 
  filter(StandCohort &gt;= 2)
```
---

class: middle

## Coercing
+ In R, factors have labels, like in SPSS.

+ So we can use factors to add a label, so that in the data frame, we can see "1" but it has a label of "Participated" (or something like that)

+ Let's start with `co16_rem` but let's make it smaller.

+ Select, `CDS`, `Name`, `AggLevel`, `DFC` using a `:` (because all the columns are in a row (`CDS` THROUGH `DFC`)
--


```r
co16dat &lt;- co16_rem %&gt;% 
  select(CDS:DFC)
```

---

## Exploring the dataset
+ First, let's check out the structure of the dataframe, co16dat


```r
class(co16dat)
```

```
## [1] "tbl_df"     "tbl"        "data.frame"
```

(Tibble is a dplyr specific object, hence, tbl, read about [Tibbles](https://r4ds.had.co.nz/tibbles.html#tibbles-vs.data.frame))
--

### Let's figure out what class each column is using str()


```r
str(co16dat)
```

```
## Classes 'tbl_df', 'tbl' and 'data.frame':	75262 obs. of  4 variables:
##  $ CDS     : chr  "01611430122697" "01611920113902" "01611920113902" "01611920113902" ...
##  $ Name    : chr  "REALM Charter High" "Impact Academy of Arts &amp; Technology" "Impact Academy of Arts &amp; Technology" "Impact Academy of Arts &amp; Technology" ...
##  $ AggLevel: chr  "D" "D" "D" "D" ...
##  $ DFC     : chr  "Y" "Y" "Y" "Y" ...
```
---
## Another way to explore a data set (and aside/introduction to apply())

+ apply(df, index, function) is the R version of a `for loop`: it iterates across rows and columns 
  + Index =1 performs some operation over rows
  + Index =2 performs some operation over columns

+ So, to get the class of each variable:


```r
apply(co16dat, 2, class)
```

```
##         CDS        Name    AggLevel         DFC 
## "character" "character" "character" "character"
```
---
## Challenge `apply()`

+ Replace `class` with the function `table`, but only on the last two columns. 

*Hint*: Remember indexing (though, there are other ways)
--

```r
apply(co16dat[3:4], 2, table)
```

```
## $AggLevel
## 
##     D     O     S     T 
## 19585  1814 53829    34 
## 
## $DFC
## 
##     N     Y 
## 61024 14238
```

```r
#or to get a cross tab

co16dat %&gt;% select(AggLevel, DFC) %&gt;% table()
```

```
##         DFC
## AggLevel     N     Y
##        D 12466  7119
##        O  1814     0
##        S 46710  7119
##        T    34     0
```

---

class: middle

### Let's make DFC a factor, right now it's of class character


```r
co16dat &lt;- co16_rem %&gt;% 
  select(CDS:DFC)

## We're going to call out the column by name
co16dat$DFC &lt;- as.factor(co16dat$DFC)


# levels() tells us what's in the factor.
levels(co16dat$DFC)
```

```
## [1] "N" "Y"
```

---
## But what if I want to add labels?
+ Best practice: make sure that if you transform a variable within a data.frame, but don't make the dataframe a new object, that the transformed variable becomes a new object


```r
#make a new column name
co16dat$DFCfactor2 &lt;- factor(co16dat$DFC,
                      levels = c("Y", "N"),
                      labels = c("Charter", "Not_Charter"))
levels(co16dat$DFC)
```

```
## [1] "N" "Y"
```

# What if it involves numbers?
---

## We'll use a built-in R dataset for this
You don't need to load any data but to get a feeling type: `View(mpg)`


```r
table(mpg$cyl)
```

```
## 
##  4  5  6  8 
## 81  4 79 70
```

```r
class(mpg$cyl)
```

```
## [1] "integer"
```

```r
# assign a new name so we don't mess up the base R dataset
# Let's make the variable cyl an ordinal variable with labels and mutate
# Ordered tells R that the factor is ordered bu could also use factor
mpg2 &lt;- mpg %&gt;% 
  mutate(cyl2 = ordered(cyl, 
                        levels = c(4, 5, 6, 8),
         labels = c("Smallest", "Small", "Medium", "Large")))

levels(mpg2$cyl2)
```

```
## [1] "Smallest" "Small"    "Medium"   "Large"
```
## Just be careful, especially with values coded as 1 or 0 but are actually factors variables, that you either turn it into a logical using `as.logical` or a factor before analysis.  


---

## Challenge, factors
1. Using `mpg2`, turn the variable in mpg2, "class" into a factor variable.
2. Make the levels go from 2seater:suv
--


```r
table(mpg2$class)
```

```
## 
##    2seater    compact    midsize    minivan     pickup subcompact 
##          5         47         41         11         33         35 
##        suv 
##         62
```

```r
class(mpg2$class)
```

```
## [1] "character"
```

```r
mpg2 &lt;- mpg2 %&gt;% 
  mutate(class2 = ordered(class,
         levels = c("2seater", "compact", "midsize", 
                    "minivan", "pickup", "subcompact", "suv")))

class(mpg2$class2)
```

```
## [1] "ordered" "factor"
```

---
# There are much more on factors than I could cover in this workshop

+ If you want to read more, go [here](https://r4ds.had.co.nz/factors.html)

+ Particularly powerful is `fct_recode` from the `forcats` package of the tidyverse 
  + Allows you to recode levels, collapse levels, or change level names.
---
# Example of `fct_recode`

Example: using the general social survey, gss (example from [https://r4ds.had.co.nz/factors.html#modifying-factor-levels](https://r4ds.had.co.nz/factors.html#modifying-factor-levels))


```r
# using built in dataset gss_cat
examplegss &lt;- gss_cat %&gt;% select(partyid)

# partyid is a factor
class(examplegss$partyid)
```

```
## [1] "factor"
```

```r
#create a new name on the left, the old name on the right
examplegss %&gt;% mutate(partyid = fct_recode(partyid,
    "Republican, strong"    = "Strong republican",
    "Republican, weak"      = "Not str republican",
    "Independent, near rep" = "Ind,near rep",
    "Independent, near dem" = "Ind,near dem",
    "Democrat, weak"        = "Not str democrat",
    "Democrat, strong"      = "Strong democrat"
  )) %&gt;%
  count(partyid)
```

```
## # A tibble: 10 x 2
##    partyid                   n
##    &lt;fct&gt;                 &lt;int&gt;
##  1 No answer               154
##  2 Don't know                1
##  3 Other party             393
##  4 Republican, strong     2314
##  5 Republican, weak       3032
##  6 Independent, near rep  1791
##  7 Independent            4119
##  8 Independent, near dem  2499
##  9 Democrat, weak         3690
## 10 Democrat, strong       3490
```

---
# Challenge, fct_recode()

1. Using fct_recode with the `mpg` data, collapse categories so that there are only two categories in the variable you created cyl2, called "small" for 4 and 5 cylinder, and "large", for 6 and 8 cylinders.  

--
# Solution

```r
table(mpg2$cyl2)
```

```
## 
## Smallest    Small   Medium    Large 
##       81        4       79       70
```

```r
mpg2 &lt;- mpg2 %&gt;%
  mutate(cyl2 = fct_recode(cyl2,
           "Small"= "Smallest",
           "Small"= "Small",
            "Large"= "Medium"))

# fct_recode: According to data-science with R, fct_recode() will leave levels that aren’t mentioned, and will warn you if you accidentally refer to a level that doesn’t exist.
sum(table(mpg2$cyl2))
```

```
## [1] 234
```

```r
sum(table(mpg2$cat.cyl))
```

```
## [1] 0
```
---
# Ok, Finally, some analysis...Go to Part III ##



---
## Tidy data principles
#### The notion of tidy data comes from Hadley Wickham, the author of the tidyverse
+ The philosophy of tidy data shapes the tidyverse

1. Each variable has its own column
2. Each observation has its own row
3. Each value has its own cell

Because...
1. Uniformity makes everything easier and you know how your data is stored
2. It makes vectorization easier

However, sometimes we need both tidy forms, and non-tidyforms of data

---
Tidy (long data):
&lt;table&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:left;"&gt; country &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; year &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; cases &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; population &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; Afghanistan &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1999 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 745 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 19987071 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; Afghanistan &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 2000 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 2666 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 20595360 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; Brazil &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1999 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 37737 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 172006362 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; Brazil &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 2000 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 80488 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 174504898 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; China &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1999 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 212258 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1272915272 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; China &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 2000 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 213766 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1280428583 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

Not tidy (wide data):
&lt;table&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:left;"&gt; country &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; 1999 &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; 2000 &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; Afghanistan &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 745 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 2666 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; Brazil &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 37737 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 80488 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; China &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 212258 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 213766 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
Years, here, are actually a value in their own right, thus values in a variable. Read more on the spread and gather functions, [here](https://r4ds.had.co.nz/tidy-data.html#spreading-and-gathering)

---
## Next functions go together, they're `group_by()` and `summarize()`

+ They do exactly what you think, but it's one of the more powerful tools in dplyr.

+ Let's use our `co16_rem` data.frame again


```r
names(co16_rem)
```

```
##  [1] "CDS"                        "Name"                      
##  [3] "AggLevel"                   "DFC"                       
##  [5] "Subgroup"                   "Subgrouptype"              
##  [7] "NumCohort"                  "NumGraduates"              
##  [9] "Cohort Graduation Rate"     "NumDropouts"               
## [11] "Cohort Dropout Rate"        "NumSpecialEducation"       
## [13] "Special Ed Completers Rate" "NumStillEnrolled"          
## [15] "Still Enrolled Rate"        "NumGED"                    
## [17] "GED Rate"                   "Year"
```
---
## The details
+ `group_by()` groups data together by some factor (such as class participation)

+ `summarize` performs some operation on the grouped data. 

+ This is often useful for carrying out summary statistics-type analysis

---
## Example `summarize()` and `group_by`

+ Let's get the average cohort size for males and females 


```r
table(co16_rem$Subgroup)
```

```
## 
##   All    EL   FEM   MAL   MIG    SD    SE 
## 23219  3173 19876 20614  1372  3578  3430
```

```r
mvf &lt;- co16_rem %&gt;% 
  select(CDS, DFC, AggLevel, Subgroup, Subgrouptype,
         NumCohort) %&gt;% 
  filter(AggLevel=="D", DFC=="N",
         Subgroup=="FEM"| Subgroup=="MAL",  
         Subgrouptype=="All") %&gt;% 
  group_by(Subgroup) %&gt;%
  summarize(mean_co = mean(NumCohort, na.rm = T), 
            se = sd(NumCohort, na.rm = T))
```
&lt;table&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:left;"&gt; Subgroup &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; mean_co &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; se &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; FEM &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 471.3473 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 961.308 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; MAL &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 491.6615 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1007.660 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
- The average number of females in a district is 471, standard error of 961.

---

class: middle

## Challenge, `group_by()` and `summarize()`

1. Edit the code above so you're grouping by Subgroup and Subgrouptype. 

2. However, with Subgroup, filter it to include Male, Female, and "All".

3. We'll look at something the state of CA always looks at: group by Subgrouptype such that we keep only those classified by CA as "Hispanic or Latinx" (5), "African American" (6), "White, not Hispanic (7), and "All".

3. With as an outcome, instead of NumCohort, use NumGraduates

---
class: middle

# Solution


```r
mvf &lt;- co16_rem %&gt;% 
  select(CDS, DFC, AggLevel, Subgroup, Subgrouptype,
         NumGraduates) %&gt;% 
  filter(AggLevel=="D", 
         DFC=="N",
         Subgroup=="MAL"| 
           Subgroup=="FEM"|
           Subgroup=="All"|
         Subgrouptype==5|
           Subgrouptype==6|
           Subgrouptype==7) %&gt;% 
  group_by(Subgroup, Subgrouptype) %&gt;%
  summarize(mean_grad = mean(NumGraduates, na.rm = T), 
            se = sd(NumGraduates, na.rm = T))
```
---
&lt;table&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:left;"&gt; Subgroup &lt;/th&gt;
   &lt;th style="text-align:left;"&gt; Subgrouptype &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; mean_grad &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; se &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; All &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 27.60000 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 23.69690 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; All &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 21.67797 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 21.83357 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; All &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 2 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 177.19718 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 281.27695 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; All &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 3 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 25.22807 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 21.12042 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; All &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 4 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 75.90964 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 111.06224 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; All &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 5 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 451.90408 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1139.34147 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
---

```r
widemvf &lt;- mvf %&gt;% 
  gather(unit, numgrad, mean_grad:se) %&gt;% 
  unite(temp1, Subgrouptype, unit, sep = ".") %&gt;% 
  spread(temp1, numgrad)

widemvf
```

```
## # A tibble: 3 x 21
## # Groups:   Subgroup [3]
##   Subgroup `0.mean_grad` `0.se` `1.mean_grad` `1.se` `2.mean_grad` `2.se`
##   &lt;chr&gt;            &lt;dbl&gt;  &lt;dbl&gt;         &lt;dbl&gt;  &lt;dbl&gt;         &lt;dbl&gt;  &lt;dbl&gt;
## 1 All               27.6   23.7          21.7   21.8          177.   281.
## 2 FEM               25.8   12.7          23.1   17.1          102.   148.
## 3 MAL               23.4   13.8          22.2   16.4          104.   149.
## # ... with 14 more variables: `3.mean_grad` &lt;dbl&gt;, `3.se` &lt;dbl&gt;,
## #   `4.mean_grad` &lt;dbl&gt;, `4.se` &lt;dbl&gt;, `5.mean_grad` &lt;dbl&gt;, `5.se` &lt;dbl&gt;,
## #   `6.mean_grad` &lt;dbl&gt;, `6.se` &lt;dbl&gt;, `7.mean_grad` &lt;dbl&gt;, `7.se` &lt;dbl&gt;,
## #   `9.mean_grad` &lt;dbl&gt;, `9.se` &lt;dbl&gt;, All.mean_grad &lt;dbl&gt;, All.se &lt;dbl&gt;
```
---
# What if I want to know frequencies?
 + Can just do the same as above but use `n()`
 

```r
freqtab &lt;- co16 %&gt;%
  group_by(Subgroup, Subgrouptype) %&gt;%
  summarise (n = n()) %&gt;%
  mutate(freq = n / sum(n))
```

&lt;table&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:left;"&gt; Subgroup &lt;/th&gt;
   &lt;th style="text-align:left;"&gt; Subgrouptype &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; n &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; freq &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; All &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 740 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.0318705 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; All &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1730 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.0745079 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; All &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 2 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 2249 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.0968603 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; All &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 3 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1419 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.0611137 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; All &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 4 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1830 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.0788148 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; All &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; 5 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 3458 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.1489298 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
---

class: middle

# Data VIZ with ggplot2
+ ggplot2 is a package built for visualizing all of our data. 

+ I might say we've done things a little backwards, it might be good to start with data visualization. 

+ the general form of ggplot is:
`ggplot(data, aes(mapping)) + geom_function(aes(mappings))`

---
## Example
.pull-left[

```r
graphdata &lt;- co16_rem %&gt;%
 filter(DFC == "N", 
        AggLevel=="D", 
        Subgroup != "All", 
        Subgrouptype=="All")
```


```r
ggplot(data=graphdata, aes(x=`Cohort Dropout Rate`, y=`GED Rate`)) + 
         geom_point(aes(color=Subgroup)) +
         geom_smooth(method = lm) 
```
]

.pull-right[
&lt;img src="r_introslides2_files/figure-html/unnamed-chunk-52-1.png" width="504" /&gt;
]
---
## Logic of ggplot2
+ "An aesthetic is a visual property of the objects in your plot. Aesthetics include things like the size, the shape, or the color of your points."
  - Garrett Grolemund &amp; Hadley Wickham in [R for Data Science](https://r4ds.had.co.nz/data-visualisation.html#aesthetic-mappings)

+ That is, we have to make some decisions about how aesthetics should be mapped to your data. 

+ For instance, the x-axis aesthetic in the plot previously, was mapped to `Cohort Dropout Rate` and the color was mapped to `subgroup`

+ Other aesthetics include size and shape

+ It's important to know the `class` of your variables
---
# Another example
Just a histogram?


```r
ggplot(data=graphdata, 
       aes(x=NumCohort)) + 
  geom_histogram()
```

&lt;img src="r_introslides2_files/figure-html/unnamed-chunk-53-1.png" width="504" /&gt;


---
## Warmup


```r
graphdata &lt;- co16_rem %&gt;%
 filter(DFC == "N", 
        AggLevel=="D", 
        Subgroup != "All", 
        Subgrouptype=="All")

plot1 &lt;- ggplot(data=graphdata, 
                aes(x=`Cohort Dropout Rate`, y=`GED Rate`)) + 
         geom_point(aes(color=Subgroup))
plot1
```

1. What variables in co16_rem are categorical? Continuous? (hint, there's one command)
1. Using `co16_rem` and the code above` map a continuous variable to color, size, and shape (using geom_point). How do these aesthetics behave differently for categorical vs. continuous variables?
1. Use ?geom_point to find out what the `stroke` aesthetic does
1. instead of `color=Subgroup` above, use `color=`GED Rate` &gt;.3)
1. What other `geom_functions` are there?

---
# Challenge: Aesthetics
+ In California, Charter Schools are often continuation schools.

+ Much of the charter school debate doesn't really look at continuation schools

Using ggplot2, answer the questions:

+ Is there a relationship between the size of a school (NumCohort) and the grad rate (`Cohort Graduation Rate`)?

+ Does this relationship look different for charters and non-charter schools?

+ How might we visualize?

+ Hint, The code for school level data for AggLevel = "S", Use subgroup and subgrouptype ="All", start with co16_rem and filter

---

```r
graphdata2 &lt;- co16_rem %&gt;% 
  filter(AggLevel=="S", 
         Subgroup=="All", 
         Subgrouptype=="All")

plot2 &lt;- ggplot(graphdata2, 
            aes(NumCohort, `Cohort Graduation Rate`))+
  geom_point(aes(color=DFC)) 
plot2
```

&lt;img src="r_introslides2_files/figure-html/unnamed-chunk-55-1.png" width="504" height="60%" style="display: block; margin: auto;" /&gt;

---
## We can also do this with pipes all the way through

```r
plot2 &lt;- co16_rem %&gt;% 
  filter(AggLevel=="S", 
         Subgroup=="All", 
         Subgrouptype=="All") %&gt;%
  ggplot(aes(x=NumCohort, y=`Cohort Graduation Rate`))+
  geom_point(aes(color=DFC)) 

plot2
```

&lt;img src="r_introslides2_files/figure-html/unnamed-chunk-56-1.png" width="504" /&gt;

---

class: middle

## Using facets

+ Can we looked at the distributions of cohort sizes by non-charters and charters?

+ Can we answer the questions from the previous slides *within* charters and non-charters?

+ Absolutely, with facet_wrap

---


```r
plot3 &lt;- ggplot(graphdata2, 
            aes(NumCohort))+
  geom_histogram() + facet_wrap(~DFC)

plot3
```

&lt;img src="r_introslides2_files/figure-html/unnamed-chunk-57-1.png" width="504" /&gt;

---
# Challenge: Facets
+ Facets use `~` which denotes a `formula.`

+ A formula is simply another data-structure in R. Don't worry about that, for now. 

+ You can have two sides to the formula. To see this, run the code:


---

```r
plot4
```

&lt;img src="r_introslides2_files/figure-html/unnamed-chunk-59-1.png" width="504" /&gt;
---
class: middle
# What happens when you replace facet_wrap with facet_grid?

---

```r
plot6 &lt;- ggplot(graphdata3, 
            aes(NumDropouts))+
  geom_histogram() + facet_grid(DFC~Subgroup)

plot6
```

&lt;img src="r_introslides2_files/figure-html/unnamed-chunk-60-1.png" width="504" /&gt;

---
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "tomorrow-night-bright",
"highlightLines": true
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();</script>

<script>
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
